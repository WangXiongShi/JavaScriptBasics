<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>Document</title>
	<style>
		*{margin:0;padding:0;}
		#wrap{width: 300px;height: 400px;border: 1px solid #ccc;position: relative; overflow: hidden;left: 200px;top: 100px;}
		#middle{width: 280px;background-color: red;position: absolute;top: 0;left: 0;}
		#sliderWrap{
			width: 20px;
			background-color: #ccc;
			height: 400px;
			position: absolute;
			right: 0px;
			top: 0px;
		}
		#slider{width: 20px;height: 40px;background-color: yellow;border-radius: 20px;position: absolute;}
	</style>
</head>
<body>
	<div id="wrap">
		<div id="middle">childNodes:所有子节点children:所有是标签类型的子节点parentNode:父节点nextElementSibling:下一个兄弟节点nextSibling(兼容ie)下一个兄弟节点包含文本节点和注释previousElementSibling:上一个兄弟节点previousSibling(兼容ie)上一个兄弟节点 包含文本节点和注释firstElementChild:第一个子节点lastElementChild:最后一个子节点childNodes:所有子节点children:所有是标签类型的子节点parentNode:父节点nextElementSibling:下一个兄弟节点nextSibling(兼容ie)下一个兄弟节点包含文本节点和注释previousElementSibling:上一个兄弟节点previousSibling(兼容ie)上一个兄弟节点 包含文本节点和注释firstElementChild:第一个子节点lastElementChild:最后一个子节点childNodes:所有子节点children:所有是标签类型的子节点parentNode:父节点nextElementSibling:下一个兄弟节点nextSibling(兼容ie)下一个兄弟节点包含文本节点和注释previousElementSibling:上一个兄弟节点previousSibling(兼容ie)上一个兄弟节点 包含文本节点和注释firstElementChild:第一个子节点lastElementChild:最后一个子节点childNodes:所有子节点children:所有是标签类型的子节点parentNode:父节点nextElementSibling:下一个兄弟节点nextSibling(兼容ie)下一个兄弟节点包含文本节点和注释previousElementSibling:上一个兄弟节点previousSibling(兼容ie)上一个兄弟节点 包含文本节点和注释firstElementChild:第一个子节点lastElementChild:最后一个子节点childNodes:所有子节点children:所有是标签类型的子节点parentNode:父节点nextElementSibling:下一个兄弟节点nextSibling(兼容ie)下一个兄弟节点包含文本节点和注释previousElementSibling:上一个兄弟节点previousSibling(兼容ie)上一个兄弟节点 包含文本节点和注释firstElementChild:第一个子节点lastElementChild:最后一个子节点childNodes:所有子节点children:所有是标签类型的子节点parentNode:父节点nextElementSibling:下一个兄弟节点nextSibling(兼容ie)下一个兄弟节点包含文本节点和注释previousElementSibling:上一个兄弟节点previousSibling(兼容ie)上一个兄弟节点 包含文本节点和注释firstElementChild:第一个子节点lastElementChild:最后一个子节点childNodes:所有子节点children:所有是标签类型的子节点parentNode:父节点nextElementSibling:下一个兄弟节点nextSibling(兼容ie)下一个兄弟节点包含文本节点和注释previousElementSibling:上一个兄弟节点previousSibling(兼容ie)上一个兄弟节点 包含文本节点和注释firstElementChild:第一个子节点lastElementChild:最后一个子节点childNodes:所有子节点children:所有是标签类型的子节点parentNode:父节点nextElementSibling:下一个兄弟节点nextSibling(兼容ie)下一个兄弟节点包含文本节点和注释previousElementSibling:上一个兄弟节点previousSibling(兼容ie)上一个兄弟节点 包含文本节点和注释firstElementChild:第一个子节点lastElementChild:最后一个子节点childNodes:所有子节点children:所有是标签类型的子节点parentNode:父节点nextElementSibling:下一个兄弟节点nextSibling(兼容ie)下一个兄弟节点包含文本节点和注释previousElementSibling:上一个兄弟节点previousSibling(兼容ie)上一个兄弟节点 包含文本节点和注释firstElementChild:第一个子节点lastElementChild:最后一个子节点childNodes:所有子节点children:所有是标签类型的子节点parentNode:父节点nextElementSibling:下一个兄弟节点nextSibling(兼容ie)下一个兄弟节点包含文本节点和注释previousElementSibling:上一个兄弟节点previousSibling(兼容ie)上一个兄弟节点 包含文本节点和注释firstElementChild:第一个子节点lastElementChild:最后一个子节点childNodes:所有子节点children:所有是标签类型的子节点parentNode:父节点nextElementSibling:下一个兄弟节点nextSibling(兼容ie)下一个兄弟节点包含文本节点和注释previousElementSibling:上一个兄弟节点previousSibling(兼容ie)上一个兄弟节点 包含文本节点和注释firstElementChild:第一个子节点lastElementChild:最后一个子节点childNodes:所有子节点children:所有是标签类型的子节点parentNode:父节点nextElementSibling:下一个兄弟节点nextSibling(兼容ie)下一个兄弟节点包含文本节点和注释previousElementSibling:上一个兄弟节点previousSibling(兼容ie)上一个兄弟节点 包含文本节点和注释firstElementChild:第一个子节点lastElementChild:最后一个子节点childNodes:所有子节点children:所有是标签类型的子节点parentNode:父节点nextElementSibling:下一个兄弟节点nextSibling(兼容ie)下一个兄弟节点包含文本节点和注释previousElementSibling:上一个兄弟节点previousSibling(兼容ie)上一个兄弟节点 包含文本节点和注释firstElementChild:第一个子节点lastElementChild:最后一个子节点</div>
		<div id="sliderWrap">
			<div id="slider"></div>
		</div>
	</div>
	
	<script src="weelfn.js"></script>
	<script>
		var wrap = document.querySelector('#wrap');
		var middle = document.querySelector('#middle');
		var sliderWrap = document.querySelector('#sliderWrap');
		var slider = document.querySelector('#slider');
		var sliderTop = 0;

		// 求比例(计算slider的高度)
		var scale = middle.offsetHeight / wrap.offsetHeight;
		// console.log(scale);
		var sliderH = sliderWrap.offsetHeight / scale;
		// console.log(sliderH);
		if(sliderH <= 40){
			sliderH = 40;
		}else if(sliderH >= sliderWrap.offsetHeight){
			sliderWrap.style.display = 'none';
		}
		slider.style.height = sliderH + 'px';

		// 键盘事件
		document.onkeydown = function(e){
			var ev = window.event || e;
			switch(ev.keyCode) {
				case 40:
					console.log('下键');
					sliderTop += 10;
					moveFn();
					break;
				case 38:
					console.log('上键');
					sliderTop -= 10;
					moveFn();
					break;
			}
		}



		// 封装滚动条上下函数
		function moveFn(){
			if(sliderTop <= 0){
				sliderTop = 0;
			}else if(sliderTop >= sliderWrap.offsetHeight - slider.offsetHeight){
				sliderTop = sliderWrap.offsetHeight - slider.offsetHeight;
			}
			var sliderScale = sliderTop / (sliderWrap.offsetHeight - sliderH); //滚动条最大走的距离
			middle.style.top = -sliderScale * (middle.offsetHeight - wrap.offsetHeight) + 'px';
			slider.style.top = sliderTop + 'px';
		}

		// 滚轮事件
		addWheelEvent(wrap,function(down){
			if(down){
				console.log('现在是上滚动滚轮');
				sliderTop -= 10;
				moveFn();
			}else{
				console.log('现在是下滚动滚轮');
				sliderTop += 10;
				moveFn();
			}
		})

		// 点击sliderWrap
		sliderWrap.onclick = function(e){
			var ev = window.event || e;
			console.log(ev.clientY);
			sliderTop = ev.clientY - sliderH / 2 - wrap.offsetTop;
			sliderTop += 10; //每次点击都加10 ,不然就是直接到点击的位置
			moveFn();
		}

		// 拖拽slider
		slider.onmousedown = function(){
			document.onmousemove = function(e){
				var ev = window.event || e;
				sliderTop = ev.clientY - sliderH / 2 - wrap.offsetTop;
				slider.style.top = sliderTop;
				moveFn();
			}
		}
		document.onmouseup = function(){
			document.onmousemove = null;
		}

		// 鼠标按下的时候取消默认事件
		document.addEventListener('mousedown',function(e){
			var ev = window.event || e;
			ev.preventDefault();
		});
	</script>
</body>
</html>