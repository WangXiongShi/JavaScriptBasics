<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>Document</title>
</head>
<body>
	<div>我是1</div>
	<div>我是2</div>
	<div>我是3</div>
	<div>我是4</div>
	<div>我是5</div>
	<script>
		// 对于js程序员来说, 闭包(closure)是一个难懂又必须征服的概念, 闭包的形成与变量的作用域以及变量的声明周期密切相关,下面我们就来简单的了解这两个知识点.

		// 1: 变量的作用域
		// 变量的作用域, 就是指变量的有效范围, 我们最常谈到的是在函数声明的变量作用域. 当在函数中声明一个变量的时候, 如果该变量前面没有带关键字var , 这个变量就会成为全局变量, 这当然是一种容易造成命名冲突的做法.

		// 另外一种情况是var关键在函数中声明变量, 这个时候的变量即是局部变量, 只有在函数内部才能访问到这个变量, 在函数外面是访问不到的.
		// 代码如下:
		 // var func = function(){ //表达式函数
		 // 	var a = 1;
		 // 	alert(a);//输出1
		 // }
		 // func();
		 // alert(a);//报错

		 //2: 变量的生命周期
		 // 除了变量的作用域之外, 另外一个跟闭包有关的概念是变量的生命周期.
		 // 对于全局变量而言, 全局变量的生命周期当然是永久的,除非我们主动销毁这个全局变量, 而对于在函数内用var关键字声明的局部变量来说, 当退出函数时, 这些局部变量将失去他们的价值, 他们会随着函数调用的结束而被销毁
		 // eg1:
		 // function func(){
		 // 	var a = 1; //退出函数局部变量a 将被销毁
		 // 	alert(a);
		 // }
		 // func();
		 // 什么是闭包:当内部函数使用到外部函数的变量时, 此时就是一个闭包结构



		 // 大白话: 一个函数其实也可以称为一个闭包, 闭包的概念是, 当内部函数用到外部函数里面的变量时, 那么此时会产生一个闭包结构,来延续变量的生命. 如果内部函数没有用到外部函数的变量,则该函数不是闭包结构


		 // 上述代码与我们之前的推论相反, 当退出函数后, 局部变量a并没有消失, 而是似乎一直在某个地方存活着, 这是因为当执行var fn = foo()时, 返回的一个匿名函数的引用, 他可以访问到foo()被调用时产生的环境, 而局部变量a一直处在这个环境里, 既然局部环境所在的环境还能被外界访问,这个局部变量就是有了不被销毁的理由. 在这里产生了一个闭包结构,局部变量的生命看起来被延续了.

		 // var divs = document.querySelectorAll('div');
		 // for (var i = 0; i < divs.length; i++) {
		 // 	divs[i].index = i;
		 // 	divs[i].onclick = function(){
		 // 		alert(this.index);
		 // 	}
		 // }
		 var divs = document.querySelectorAll('div');
		 for (var i = 0; i < divs.length; i++) {
		 	(function(a){
				divs[a].onclick = function(){
			 		alert(a);
			 	}
		 	})(i)
		 }
	</script>
</body>
</html>